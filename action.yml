name: 'Upload Package to Thunderstore'
description: 'Builds, validates, packages and publishes a Thunderstore pacakge'
author: 'WarperSan'
branding:
  icon: 'package'
  color: 'purple'

inputs:
  # Required inputs
  community:
    description: 'Slug of the community to publish the package to'
    required: true
  team:
    description: 'Name of team publishing the package'
    required: true
  name:
    description: 'Name of the package'
    required: true
  version:
    description: 'Semantic version of the package'
    required: true
  files:
    description: 'List of files needed by the package'
    required: true

  # Optional inputs
  categories:
    description: 'List of slugs for each category the package belongs to'
    required: false
    default: ''
  description:
    description: 'Short description of the package'
    required: false
    default: ''
  dependencies:
    description: 'List of dependency strings for each package needed by the package'
    required: false
    default: ''
  website:
    description: "URL of the package's website"
    required: false
    default: ''
  has-nsfw:
    description: 'Marks the package as "Not Safe For Work" (NSFW)'
    required: false
    default: 'false'

  # Secrets
  token:
    description: 'Authentication token used by the service account'
    required: true

  # Options
  dotnet-configuration:
    description: 'Build configuration to use when building and testing the package'
    required: false
    default: 'Release'
  repository:
    description: 'URL of the hosting server'
    required: false
    default: 'https://thunderstore.io'
  package-files:
    description: 'List of files for the listing page'
    required: false
    default: |
      ./icon.png
      ./README.md
      ./CHANGELOG.md
      ./LICENSE?(.txt|.md)

outputs:
  zip-path:
    description: "Absolute path to the generated zip"
    value: ${{ steps.zip.outputs.zip-path }}

runs:
  using: 'composite'
  steps:
    - name: Install ThunderPipe
      shell: bash
      run: |
        dotnet tool install ThunderPipe --global --version 1.0.1
        echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

    ### ---
    ### Validate Inputs
    ### ---
    - name: Validate Community
      shell: bash
      run: |
        ThunderPipe validate community "$COMMUNITY" \
          --repository "$REPOSITORY"
      env:
        COMMUNITY: ${{ inputs.community }}
        REPOSITORY: ${{ inputs.repository }}

    - name: Validate Categories
      shell: bash
      run: |
        if [ -n "$CATEGORIES" ]; then
          mapfile -t categories <<< "$CATEGORIES"

          OPTIONS=()
          
          for category in "${categories[@]}";
          do
            [ -z "$category" ] && continue

            OPTIONS+=('--category')
            OPTIONS+=("$category")
          done
      
          echo "${OPTIONS[@]}"
      
          ThunderPipe validate categories "$COMMUNITY" "${OPTIONS[@]}" \
            --repository "$REPOSITORY"
        fi
      env:
        COMMUNITY: ${{ inputs.community }}
        CATEGORIES: ${{ inputs.categories }}
        REPOSITORY: ${{ inputs.repository }}

    - name: Validate Dependencies
      shell: bash
      run: |
        if [ -n "$DEPENDENCIES" ]; then
          mapfile -t dependencies <<< "$DEPENDENCIES"
          
          DEPS=()
        
          for dep in "${dependencies[@]}"; do
            [[ -z "$dep" ]] && continue
            DEPS+=("$dep")
          done

          if [ ${#DEPS[@]} -gt 0 ]; then
            ThunderPipe validate dependencies "${DEPS[@]}" \
            --repository "$REPOSITORY"
         fi
        fi
      env:
        DEPENDENCIES: ${{ inputs.dependencies }}
        REPOSITORY: ${{ inputs.repository }}

    ### ---
    ### Build Package
    ### ---
    - name: Build Package
      shell: bash
      run: dotnet build --no-restore -c "$CONFIGURATION"
      env:
        CONFIGURATION: ${{ inputs.dotnet-configuration }}

    - name: Test Package
      shell: bash
      run: dotnet test --no-build --no-restore -c "$CONFIGURATION"
      env:
        CONFIGURATION: ${{ inputs.dotnet-configuration }}

    ### ---
    ### Prepare Package
    ### ---
    - name: Copy Package Files
      shell: bash
      run: |
        rm -rf "$DESTINATION"
        mkdir -p "$DESTINATION"
        
        shopt -s nullglob
        mapfile -t patterns <<< "$FILES"
  
        for pattern in "${patterns[@]}"; do
          [[ -z "$pattern" ]] && continue
        
          for file in $pattern; do
            [[ -f "$file" ]] && cp "$file" "$DESTINATION"
          done
        done
      env:
        FILES: ${{ inputs.package-files }}
        DESTINATION: '${{ github.workspace }}/package/'

    - name: Copy Build Files
      shell: bash
      run: |
        set -euxo pipefail
        
        rm -rf "$DESTINATION"
        mkdir -p "$DESTINATION"
        
        shopt -s nullglob
        mapfile -t patterns <<< "$FILES"
        
        for pattern in "${patterns[@]}"; do
          [[ -z "$pattern" ]] && continue
        
          for file in $pattern; do
            [[ -f "$file" ]] || continue
            
            cp "$file" "$DESTINATION"
          done
        done
      env:
        FILES: ${{ inputs.files }}
        DESTINATION: '${{ github.workspace }}/package/plugins/'

    - name: Create manifest.json
      shell: bash
      run: |
        OPTIONS=()
        
        if [ -n "$DIRECTORY" ]; then
          OPTIONS+=('--directory')
          OPTIONS+=("$DIRECTORY")
        fi

        if [ -n "$DESCRIPTION" ]; then
          OPTIONS+=('--description')
          OPTIONS+=("$DESCRIPTION")
        fi
        
        if [ -n "$WEBSITE" ]; then
          OPTIONS+=('--website')
          OPTIONS+=("$WEBSITE")
        fi
        
        if [ -n "$DEPENDENCIES" ]; then
          mapfile -t dependencies <<< "$DEPENDENCIES"
        
          for dependency in "${dependencies[@]}"; do
            [[ -z "$dependency" ]] && continue

            OPTIONS+=('--dependency')
            OPTIONS+=("$dependency")
          done
        fi
        
        ThunderPipe create manifest "$NAME" "$VERSION" "${OPTIONS[@]}"
      env:
        NAME: ${{ inputs.name }}
        DESCRIPTION: ${{ inputs.description }}
        VERSION: ${{ inputs.version }}
        WEBSITE: ${{ inputs.website }}
        DEPENDENCIES: ${{ inputs.dependencies }}
        DIRECTORY: '${{ github.workspace }}/package/'

    - name: Validate Package
      shell: bash
      run: |
        ThunderPipe validate package "$PACKAGE_FOLDER" \
          --token "$TOKEN" \
          --team "$TEAM" \
          --repository "$REPOSITORY"
      env:
        PACKAGE_FOLDER: '${{ github.workspace }}/package/'
        TOKEN: ${{ inputs.token }}
        TEAM: ${{ inputs.team }}
        REPOSITORY: ${{ inputs.repository }}

    ### ---
    ### Publish Package
    ### ---
    - name: Zip Package
      id: zip
      shell: bash
      run: |
        rm -f "$OUTPUT_FILE"
  
        (
          cd "$SOURCE_FOLDER"
          zip -r "$OUTPUT_FILE" .
        )
        
        echo "zip-path=$OUTPUT_FILE" >> "$GITHUB_OUTPUT"
      env:
        SOURCE_FOLDER: '${{ github.workspace }}/package/'
        OUTPUT_FILE: '${{ github.workspace }}/${{ inputs.team }}-${{ inputs.name }}-${{ inputs.version }}.zip'

    - name: Publish Package
      shell: bash
      run: |
        OPTIONS=()

        if [ -n "$REPOSITORY" ]; then
          OPTIONS+=('--repository')
          OPTIONS+=("$REPOSITORY")
        fi

        if [ "$HAS_NSFW" = 'true' ]; then
          OPTIONS+=('--has-nsfw')
        fi

        if [ -n "$CATEGORIES" ]; then
          mapfile -t categories <<< "$CATEGORIES"
        
          for category in "${categories[@]}";
          do
            [ -z "$category" ] && continue
        
            OPTIONS+=('--category')
            OPTIONS+=("$category")
          done
        fi

        ThunderPipe publish "$FILE_PATH" "$TEAM" "$COMMUNITY" \
          --token "$TOKEN" \
          "${OPTIONS[@]}"
      env:
        FILE_PATH: ${{ steps.zip.outputs.zip-path }}
        TEAM: ${{ inputs.team }}
        COMMUNITY: ${{ inputs.community }}
        TOKEN: ${{ inputs.token }}
        HAS_NSFW: ${{ inputs.has-nsfw }}
        CATEGORIES: ${{ inputs.categories }}
        REPOSITORY: ${{ inputs.repository }}
